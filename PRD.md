# üìã **NFT –ú–∏–Ω—Ç–∏–Ω–≥ Backend - –¢–µ—Ö–Ω–∏—á–µ—Å–∫–æ–µ –∑–∞–¥–∞–Ω–∏–µ**

## üéØ **–û–±–∑–æ—Ä –ø—Ä–æ–µ–∫—Ç–∞**

**–¶–µ–ª—å:** –°–æ–∑–¥–∞—Ç—å Express.js backend –¥–ª—è –º–∏–Ω—Ç–∏–Ω–≥–∞ Compressed NFT –≤ —ç–∫–æ—Å–∏—Å—Ç–µ–º–µ PEcamp  
**–ü–ª–∞—Ç—Ñ–æ—Ä–º–∞:** TimeWeb Hosting (–ì–æ–ª–ª–∞–Ω–¥–∏—è)  
**–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è:** –°—É—â–µ—Å—Ç–≤—É—é—â–∏–π Next.js frontend –Ω–∞ Vercel  
**Blockchain:** Solana (Compressed NFT —á–µ—Ä–µ–∑ Metaplex Bubblegum)

---

## üèóÔ∏è **1. –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞**

### **–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π:**
```
backend/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ routes/           # API endpoints
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mint.js       # NFT –º–∏–Ω—Ç–∏–Ω–≥ –æ–ø–µ—Ä–∞—Ü–∏–∏
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ collections.js # –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ü–∏—è–º–∏
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ upload.js     # –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤ –Ω–∞ IPFS
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ status.js     # –°—Ç–∞—Ç—É—Å—ã –æ–ø–µ—Ä–∞—Ü–∏–π
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ health.js     # Health checks
‚îÇ   ‚îú‚îÄ‚îÄ services/         # –ë–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ solana.js     # Solana –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pinata.js     # IPFS –æ–ø–µ—Ä–∞—Ü–∏–∏
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ queue.js      # –û—á–µ—Ä–µ–¥–∏ –∑–∞–¥–∞—á
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ supabase.js   # Database –æ–ø–µ—Ä–∞—Ü–∏–∏
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.js # –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö
‚îÇ   ‚îú‚îÄ‚îÄ middleware/       # Express middleware
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.js       # API –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cors.js       # CORS –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rateLimit.js  # Rate limiting
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ errorHandler.js # –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
‚îÇ   ‚îú‚îÄ‚îÄ utils/            # –£—Ç–∏–ª–∏—Ç—ã
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ wallet.js     # –ö–æ—à–µ–ª–µ–∫ –æ–ø–µ—Ä–∞—Ü–∏–∏
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logger.js     # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cache.js      # –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ constants.js  # –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
‚îÇ   ‚îú‚îÄ‚îÄ types/            # TypeScript —Ç–∏–ø—ã
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.d.ts
‚îÇ   ‚îî‚îÄ‚îÄ app.js           # Express –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
‚îú‚îÄ‚îÄ reference-integration/ # –ê–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π reference-code
‚îÇ   ‚îú‚îÄ‚îÄ mint-single.js
‚îÇ   ‚îú‚îÄ‚îÄ mint-batch.js
‚îÇ   ‚îú‚îÄ‚îÄ upload-assets.js
‚îÇ   ‚îî‚îÄ‚îÄ create-tree.js
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ database.js      # –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö
‚îÇ   ‚îú‚îÄ‚îÄ blockchain.js    # Solana –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
‚îÇ   ‚îî‚îÄ‚îÄ storage.js       # IPFS –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
‚îú‚îÄ‚îÄ tests/               # –¢–µ—Å—Ç—ã
‚îú‚îÄ‚îÄ docs/                # –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è
‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ ecosystem.config.js  # PM2 –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
‚îî‚îÄ‚îÄ README.md
```

---

## üîó **2. API Endpoints**

### **üé® NFT –ú–∏–Ω—Ç–∏–Ω–≥ (`/api/mint`)**

#### **POST `/api/mint/single`** - –ú–∏–Ω—Ç –æ–¥–Ω–æ–≥–æ NFT
```typescript
Request:
{
  collectionId: string;        // ID –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –∏–∑ –±–∞–∑—ã
  recipient: string;           // Solana wallet address
  metadata: {
    name: string;              // –ù–∞–∑–≤–∞–Ω–∏–µ NFT
    description?: string;      // –û–ø–∏—Å–∞–Ω–∏–µ
    image: File | string;      // –§–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–ª–∏ IPFS URI
    attributes?: Array<{       // –ê—Ç—Ä–∏–±—É—Ç—ã NFT
      trait_type: string;
      value: string;
    }>;
    external_url?: string;     // –í–Ω–µ—à–Ω—è—è —Å—Å—ã–ª–∫–∞
  };
  copies?: number;             // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–ø–∏–π (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 1)
}

Response:
{
  success: boolean;
  data: {
    transactionId: string;     // ID –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–ª—è tracking
    signatures: string[];     // Solana transaction signatures
    leafIndexes: number[];    // Merkle tree leaf indexes
    assetIds: string[];       // Compressed NFT asset IDs
    ipfsUris: string[];       // IPFS URI –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
  };
  message: string;
}
```

#### **POST `/api/mint/batch`** - Batch –º–∏–Ω—Ç–∏–Ω–≥
```typescript
Request:
{
  collectionId: string;
  recipient: string;
  nfts: Array<{
    name: string;
    description?: string;
    image: File | string;
    attributes?: Array<{
      trait_type: string;
      value: string;
    }>;
    copies?: number;
  }>;
  batchSize?: number;          // –†–∞–∑–º–µ—Ä –±–∞—Ç—á–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 10)
  delayBetweenBatches?: number; // –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –±–∞—Ç—á–∞–º–∏ (–º—Å)
}

Response:
{
  success: boolean;
  data: {
    transactionId: string;
    totalNfts: number;
    estimatedTime: number;     // –û—Ü–µ–Ω–æ—á–Ω–æ–µ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è (—Å–µ–∫—É–Ω–¥—ã)
    batchCount: number;
  };
  message: string;
}
```

#### **GET `/api/mint/status/:transactionId`** - –°—Ç–∞—Ç—É—Å –æ–ø–µ—Ä–∞—Ü–∏–∏
```typescript
Response:
{
  success: boolean;
  data: {
    transactionId: string;
    status: 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled';
    progress: {
      total: number;
      completed: number;
      failed: number;
      percentage: number;
      currentItem?: string;
      estimatedTimeLeft?: number; // —Å–µ–∫—É–Ω–¥—ã
    };
    results?: Array<{
      signature?: string;
      leafIndex?: number;
      assetId?: string;
      error?: string;
      status: 'success' | 'failed';
    }>;
    startTime: string;         // ISO timestamp
    endTime?: string;          // ISO timestamp
    error?: string;
  };
}
```

#### **DELETE `/api/mint/cancel/:transactionId`** - –û—Ç–º–µ–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏–∏
```typescript
Response:
{
  success: boolean;
  message: string;
}
```

### **üìÅ –ö–æ–ª–ª–µ–∫—Ü–∏–∏ (`/api/collections`)**

#### **GET `/api/collections`** - –°–ø–∏—Å–æ–∫ –∫–æ–ª–ª–µ–∫—Ü–∏–π
```typescript
Query Params:
- status?: 'active' | 'paused' | 'completed'
- allowMinting?: boolean
- page?: number
- limit?: number

Response:
{
  success: boolean;
  data: {
    collections: Array<{
      id: string;
      name: string;
      description: string;
      symbol: string;
      treeAddress: string;
      collectionAddress?: string;
      creatorAddress?: string;
      capacity: number;
      minted: number;
      imageUrl?: string;
      externalUrl?: string;
      hasValidTree: boolean;
      supportsDAS: boolean;
      status: 'active' | 'paused' | 'completed';
      isPublic: boolean;
      allowMinting: boolean;
      createdAt: string;
      updatedAt: string;
    }>;
    pagination: {
      total: number;
      page: number;
      limit: number;
      totalPages: number;
    };
  };
}
```

#### **POST `/api/collections/sync/:id`** - –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å –±–ª–æ–∫—á–µ–π–Ω–æ–º
```typescript
Response:
{
  success: boolean;
  data: {
    updated: {
      minted: number;
      capacity: number;
      hasValidTree: boolean;
    };
  };
  message: string;
}
```

### **üì§ –ó–∞–≥—Ä—É–∑–∫–∞ (`/api/upload`)**

#### **POST `/api/upload/ipfs`** - –ó–∞–≥—Ä—É–∑–∫–∞ –Ω–∞ IPFS
```typescript
Request: FormData
- files: File[]              // –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
- metadata?: string          // JSON –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ

Response:
{
  success: boolean;
  data: {
    uploads: Array<{
      filename: string;
      ipfsHash: string;
      ipfsUri: string;
      gatewayUrl: string;
      size: number;
    }>;
  };
}
```

### **üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ (`/api/stats`)**

#### **GET `/api/stats/overview`** - –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
```typescript
Response:
{
  success: boolean;
  data: {
    totalCollections: number;
    totalMinted: number;
    totalCapacity: number;
    activeOperations: number;
    last24Hours: {
      minted: number;
      operations: number;
      successRate: number;
    };
    walletBalance: number;     // SOL –±–∞–ª–∞–Ω—Å
  };
}
```

---

## üîê **3. –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è**

### **`.env` –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è:**
```bash
# === –û–°–ù–û–í–ù–´–ï –ù–ê–°–¢–†–û–ô–ö–ò ===
NODE_ENV=production
PORT=8080                    # –ò–ª–∏ –æ—Å—Ç–∞–≤–∏—Ç—å –ø—É—Å—Ç—ã–º –¥–ª—è –∞–≤—Ç–æ–Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è

# === SOLANA BLOCKCHAIN ===
PRIVATE_KEY=                 # Base58 –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á –∫–æ—à–µ–ª—å–∫–∞
RPC_URL=                     # Alchemy Solana Mainnet URL
BACKUP_RPC_URLS=             # –ó–∞–ø–∞—Å–Ω—ã–µ RPC —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é
NETWORK=mainnet-beta         # mainnet-beta | devnet | testnet
SOLANA_COMMITMENT=confirmed  # confirmed | finalized | processed

# === IPFS STORAGE ===
PINATA_API_KEY=              # Pinata API –∫–ª—é—á
PINATA_SECRET_KEY=           # Pinata Secret –∫–ª—é—á
PINATA_GATEWAY=              # Dedicated Pinata gateway (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)

# === DATABASE ===
SUPABASE_URL=                # Supabase Project URL
SUPABASE_SERVICE_ROLE_KEY=   # Service Role Key (–ø–æ–ª–Ω—ã–π –¥–æ—Å—Ç—É–ø)
SUPABASE_ANON_KEY=           # Anonymous Key (–¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π)

# === –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–¨ ===
API_KEY=                     # API –∫–ª—é—á –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ —Å —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞
JWT_SECRET=                  # JWT —Å–µ–∫—Ä–µ—Ç (64+ —Å–∏–º–≤–æ–ª–æ–≤)
CORS_ORIGINS=                # –†–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–µ origins —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é

# === –ö–≠–®–ò–†–û–í–ê–ù–ò–ï ===
REDIS_URL=                   # Redis URL (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
CACHE_TTL=300               # TTL –∫—ç—à–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö

# === RATE LIMITING ===
RATE_LIMIT_WINDOW=900       # –û–∫–Ω–æ rate limit (—Å–µ–∫—É–Ω–¥—ã)
RATE_LIMIT_MAX=100          # –ú–∞–∫—Å–∏–º—É–º –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ –æ–∫–Ω–µ

# === –û–ß–ï–†–ï–î–ò ===
QUEUE_BATCH_SIZE=10         # –†–∞–∑–º–µ—Ä batch –¥–ª—è –º–∏–Ω—Ç–∏–Ω–≥–∞
QUEUE_DELAY_MS=1000         # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏
QUEUE_MAX_RETRIES=3         # –ú–∞–∫—Å–∏–º—É–º –ø–æ–≤—Ç–æ—Ä–æ–≤ –ø—Ä–∏ –æ—à–∏–±–∫–µ

# === –ú–û–ù–ò–¢–û–†–ò–ù–ì ===
LOG_LEVEL=info              # error | warn | info | debug
ENABLE_METRICS=true         # –í–∫–ª—é—á–∏—Ç—å –º–µ—Ç—Ä–∏–∫–∏
WEBHOOK_URL=                # URL –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
```

---

## üõ°Ô∏è **4. –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å**

### **Middleware –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏:**
```javascript
// middleware/auth.js
const authMiddleware = (req, res, next) => {
  const apiKey = req.headers['x-api-key'];
  const authHeader = req.headers.authorization;
  
  // API Key –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
  if (apiKey === process.env.API_KEY) {
    return next();
  }
  
  // JWT –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è (–¥–ª—è –±—É–¥—É—â–∏—Ö —Ñ–∏—á)
  if (authHeader?.startsWith('Bearer ')) {
    // JWT verification logic
  }
  
  return res.status(401).json({ 
    success: false, 
    error: 'Unauthorized' 
  });
};
```

### **Rate Limiting:**
```javascript
// middleware/rateLimit.js
const rateLimit = require('express-rate-limit');

const createRateLimit = (windowMs, max, message) => {
  return rateLimit({
    windowMs: windowMs * 1000,
    max,
    message: { success: false, error: message },
    standardHeaders: true,
    legacyHeaders: false,
  });
};

// –†–∞–∑–ª–∏—á–Ω—ã–µ –ª–∏–º–∏—Ç—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö endpoints
const mintRateLimit = createRateLimit(900, 10, 'Too many mint requests');
const uploadRateLimit = createRateLimit(300, 50, 'Too many upload requests');
```

### **–í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö:**
```javascript
// services/validation.js
const validateMintRequest = (data) => {
  const errors = [];
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ Solana –∞–¥—Ä–µ—Å–∞
  if (!isValidSolanaAddress(data.recipient)) {
    errors.push('Invalid recipient address');
  }
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
  if (!data.metadata?.name || data.metadata.name.length > 200) {
    errors.push('Invalid NFT name');
  }
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–µ–∫—Ü–∏–∏
  if (!isValidUUID(data.collectionId)) {
    errors.push('Invalid collection ID');
  }
  
  return errors;
};
```

---

## üíæ **5. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö**

### **–ù–æ–≤—ã–µ —Ç–∞–±–ª–∏—Ü—ã (SQL –º–∏–≥—Ä–∞—Ü–∏–∏):**

#### **`mint_operations` —Ç–∞–±–ª–∏—Ü–∞:**
```sql
CREATE TABLE mint_operations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  transaction_id VARCHAR(64) UNIQUE NOT NULL,
  collection_id UUID REFERENCES nft_collections(id),
  recipient VARCHAR(44) NOT NULL,
  status VARCHAR(20) DEFAULT 'pending',
  operation_type VARCHAR(20) DEFAULT 'mint', -- 'mint' | 'batch_mint'
  total_nfts INTEGER DEFAULT 1,
  completed_nfts INTEGER DEFAULT 0,
  failed_nfts INTEGER DEFAULT 0,
  batch_size INTEGER DEFAULT 1,
  metadata JSONB,
  results JSONB DEFAULT '[]',
  error_message TEXT,
  start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  end_time TIMESTAMP WITH TIME ZONE,
  estimated_completion TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_mint_operations_transaction_id ON mint_operations(transaction_id);
CREATE INDEX idx_mint_operations_status ON mint_operations(status);
CREATE INDEX idx_mint_operations_created_at ON mint_operations(created_at DESC);
```

#### **`mint_results` —Ç–∞–±–ª–∏—Ü–∞:**
```sql
CREATE TABLE mint_results (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  operation_id UUID REFERENCES mint_operations(id),
  nft_name VARCHAR(200),
  signature VARCHAR(88),
  leaf_index INTEGER,
  asset_id VARCHAR(44),
  ipfs_hash VARCHAR(64),
  ipfs_uri TEXT,
  status VARCHAR(20) DEFAULT 'pending',
  error_message TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_mint_results_operation_id ON mint_results(operation_id);
CREATE INDEX idx_mint_results_signature ON mint_results(signature);
```

### **Supabase —Å–µ—Ä–≤–∏—Å:**
```javascript
// services/supabase.js
const { createClient } = require('@supabase/supabase-js');

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY,
  {
    auth: {
      autoRefreshToken: false,
      persistSession: false
    }
  }
);

class DatabaseService {
  // –°–æ–∑–¥–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –º–∏–Ω—Ç–∏–Ω–≥–∞
  async createMintOperation(data) {
    const { data: operation, error } = await supabase
      .from('mint_operations')
      .insert([{
        transaction_id: data.transactionId,
        collection_id: data.collectionId,
        recipient: data.recipient,
        operation_type: data.operationType,
        total_nfts: data.totalNfts,
        batch_size: data.batchSize,
        metadata: data.metadata
      }])
      .select()
      .single();
      
    if (error) throw error;
    return operation;
  }
  
  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –æ–ø–µ—Ä–∞—Ü–∏–∏
  async updateMintOperation(transactionId, updates) {
    const { data, error } = await supabase
      .from('mint_operations')
      .update({
        ...updates,
        updated_at: new Date().toISOString()
      })
      .eq('transaction_id', transactionId)
      .select()
      .single();
      
    if (error) throw error;
    return data;
  }
  
  // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –º–∏–Ω—Ç–∞
  async saveMintResult(operationId, result) {
    const { data, error } = await supabase
      .from('mint_results')
      .insert([{
        operation_id: operationId,
        nft_name: result.name,
        signature: result.signature,
        leaf_index: result.leafIndex,
        asset_id: result.assetId,
        ipfs_hash: result.ipfsHash,
        ipfs_uri: result.ipfsUri,
        status: result.status,
        error_message: result.error
      }]);
      
    if (error) throw error;
    return data;
  }
}
```

---

## ‚ö° **6. –û—á–µ—Ä–µ–¥–∏ –∏ background –æ–±—Ä–∞–±–æ—Ç–∫–∞**

### **Queue —Å–∏—Å—Ç–µ–º–∞:**
```javascript
// services/queue.js
const EventEmitter = require('events');

class MintQueue extends EventEmitter {
  constructor() {
    super();
    this.queue = [];
    this.processing = new Map(); // transactionId -> AbortController
    this.isProcessing = false;
  }
  
  // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ –≤ –æ—á–µ—Ä–µ–¥—å
  async addMintTask(task) {
    const transactionId = this.generateTransactionId();
    
    const queueItem = {
      transactionId,
      type: task.type, // 'single' | 'batch'
      data: task.data,
      priority: task.priority || 0,
      retries: 0,
      maxRetries: 3,
      createdAt: new Date(),
      status: 'queued'
    };
    
    this.queue.push(queueItem);
    this.emit('taskAdded', queueItem);
    
    // –ê–≤—Ç–æ–∑–∞–ø—É—Å–∫ –æ–±—Ä–∞–±–æ—Ç–∫–∏
    if (!this.isProcessing) {
      this.processQueue();
    }
    
    return transactionId;
  }
  
  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—á–µ—Ä–µ–¥–∏
  async processQueue() {
    if (this.isProcessing || this.queue.length === 0) return;
    
    this.isProcessing = true;
    
    while (this.queue.length > 0) {
      const task = this.queue.shift();
      
      try {
        await this.processTask(task);
      } catch (error) {
        await this.handleTaskError(task, error);
      }
      
      // –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–¥–∞—á–∞–º–∏
      await this.delay(process.env.QUEUE_DELAY_MS || 1000);
    }
    
    this.isProcessing = false;
  }
  
  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–¥–µ–ª—å–Ω–æ–π –∑–∞–¥–∞—á–∏
  async processTask(task) {
    const abortController = new AbortController();
    this.processing.set(task.transactionId, abortController);
    
    task.status = 'processing';
    this.emit('taskStarted', task);
    
    try {
      let result;
      
      if (task.type === 'single') {
        result = await this.mintSingleNFT(task.data, abortController.signal);
      } else if (task.type === 'batch') {
        result = await this.mintBatchNFTs(task.data, abortController.signal);
      }
      
      task.status = 'completed';
      task.result = result;
      this.emit('taskCompleted', task);
      
    } finally {
      this.processing.delete(task.transactionId);
    }
  }
  
  // –û—Ç–º–µ–Ω–∞ –∑–∞–¥–∞—á–∏
  cancelTask(transactionId) {
    const abortController = this.processing.get(transactionId);
    if (abortController) {
      abortController.abort();
      this.processing.delete(transactionId);
    }
    
    // –£–¥–∞–ª–µ–Ω–∏–µ –∏–∑ –æ—á–µ—Ä–µ–¥–∏
    const queueIndex = this.queue.findIndex(t => t.transactionId === transactionId);
    if (queueIndex !== -1) {
      this.queue.splice(queueIndex, 1);
    }
    
    this.emit('taskCancelled', { transactionId });
  }
}
```

---

## üîó **7. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Solana (–∏–∑ reference-code)**

### **–ê–¥–∞–ø—Ç–∞—Ü–∏—è reference-code:**
```javascript
// services/solana.js
const { createUmi } = require("@metaplex-foundation/umi-bundle-defaults");
const bubblegum = require("@metaplex-foundation/mpl-bubblegum");
const { keypairIdentity, publicKey } = require("@metaplex-foundation/umi");
const bs58 = require("bs58");

class SolanaService {
  constructor() {
    this.umi = null;
    this.initialized = false;
  }
  
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Umi (–∏–∑ create_merkle_tree.js)
  async initialize() {
    if (this.initialized) return;
    
    const rpcUrls = [
      process.env.RPC_URL,
      ...process.env.BACKUP_RPC_URLS?.split(',') || []
    ].filter(Boolean);
    
    let connected = false;
    
    for (const rpcUrl of rpcUrls) {
      try {
        this.umi = this.createUmiInstance(rpcUrl);
        await this.umi.rpc.getLatestBlockhash();
        console.log(`‚úÖ Connected to Solana RPC: ${rpcUrl}`);
        connected = true;
        break;
      } catch (error) {
        console.log(`‚ùå Failed to connect to ${rpcUrl}: ${error.message}`);
      }
    }
    
    if (!connected) {
      throw new Error('Failed to connect to any Solana RPC endpoint');
    }
    
    // –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ—à–µ–ª—å–∫–∞
    const secretKeyBytes = bs58.decode(process.env.PRIVATE_KEY);
    const umiKeypair = this.umi.eddsa.createKeypairFromSecretKey(secretKeyBytes);
    this.umi.use(keypairIdentity(umiKeypair));
    this.umi.use(bubblegum.mplBubblegum());
    
    this.initialized = true;
  }
  
  // –°–æ–∑–¥–∞–Ω–∏–µ UMI instance (–∏–∑ reference-code)
  createUmiInstance(url) {
    const umi = createUmi(url, {
      httpOptions: { 
        fetchMiddleware: (req, next) => next(req)
      }
    });
    
    // –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ confirm –¥–ª—è HTTP-only —Ä–µ–∂–∏–º–∞
    umi.rpc.confirm = async (signature, commitment) => {
      let retries = 10;
      while (retries > 0) {
        const result = await umi.rpc.getSignatureStatuses([signature], { commitment });
        if (result?.value?.[0]) {
          if (result.value[0].err) {
            throw new Error(`Transaction failed: ${JSON.stringify(result.value[0].err)}`);
          }
          return signature;
        }
        await this.delay(2000);
        retries--;
      }
      throw new Error(`Transaction ${bs58.encode(signature)} not confirmed after 10 attempts`);
    };
    
    return umi;
  }
  
  // –ú–∏–Ω—Ç –æ–¥–Ω–æ–≥–æ NFT (–∞–¥–∞–ø—Ç–∞—Ü–∏—è –∏–∑ mint_nft.js)
  async mintSingleNFT(params) {
    await this.initialize();
    
    const { collectionAddress, treeAddress, recipient, metadata } = params;
    
    try {
      const nftMetadata = {
        name: metadata.name,
        symbol: metadata.symbol || "cNFT",
        uri: metadata.uri,
        sellerFeeBasisPoints: 0,
        collection: {
          key: publicKey(collectionAddress),
          verified: false,
        },
        creators: metadata.creators || [
          {
            address: this.umi.identity.publicKey,
            share: 100,
            verified: false,
          },
        ],
      };
      
      const builder = await bubblegum.mintToCollectionV1(this.umi, {
        leafOwner: publicKey(recipient),
        merkleTree: publicKey(treeAddress),
        metadata: nftMetadata,
        collectionMint: publicKey(collectionAddress),
      });
      
      const result = await builder.sendAndConfirm(this.umi, {
        send: { skipPreflight: true },
        confirm: { 
          strategy: { 
            type: 'blockhash', 
            blockhash: (await this.umi.rpc.getLatestBlockhash()).blockhash 
          } 
        }
      });
      
      return {
        signature: bs58.encode(result.signature),
        success: true
      };
      
    } catch (error) {
      console.error('Mint failed:', error);
      throw error;
    }
  }
  
  // –ü–æ–ª—É—á–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ –∫–æ—à–µ–ª—å–∫–∞
  async getWalletBalance() {
    await this.initialize();
    const balance = await this.umi.rpc.getBalance(this.umi.identity.publicKey);
    return balance.basisPoints / 1e9; // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ SOL
  }
  
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

---

## üì¶ **8. IPFS –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è (Pinata)**

### **Pinata —Å–µ—Ä–≤–∏—Å:**
```javascript
// services/pinata.js
const pinataSDK = require('@pinata/sdk');
const fs = require('fs');
const path = require('path');

class PinataService {
  constructor() {
    this.pinata = new pinataSDK(
      process.env.PINATA_API_KEY,
      process.env.PINATA_SECRET_KEY
    );
    this.gateway = process.env.PINATA_GATEWAY || 'https://gateway.pinata.cloud';
  }
  
  // –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞ (–∏–∑ upload_assets.js)
  async uploadFile(filePath, filename) {
    try {
      const stream = fs.createReadStream(filePath);
      const result = await this.pinata.pinFileToIPFS(stream, {
        pinataMetadata: { name: filename }
      });
      
      return {
        ipfsHash: result.IpfsHash,
        ipfsUri: `ipfs://${result.IpfsHash}`,
        gatewayUrl: `${this.gateway}/ipfs/${result.IpfsHash}`,
        size: result.PinSize
      };
    } catch (error) {
      console.error('File upload failed:', error);
      throw error;
    }
  }
  
  // –ó–∞–≥—Ä—É–∑–∫–∞ JSON –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
  async uploadJSON(jsonData, filename) {
    try {
      const result = await this.pinata.pinJSONToIPFS(jsonData, {
        pinataMetadata: { name: filename }
      });
      
      return {
        ipfsHash: result.IpfsHash,
        ipfsUri: `ipfs://${result.IpfsHash}`,
        gatewayUrl: `${this.gateway}/ipfs/${result.IpfsHash}`
      };
    } catch (error) {
      console.error('JSON upload failed:', error);
      throw error;
    }
  }
  
  // Batch –∑–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤
  async uploadMultipleFiles(files) {
    const results = [];
    
    for (const file of files) {
      try {
        const result = await this.uploadFile(file.path, file.name);
        results.push({
          filename: file.name,
          ...result,
          status: 'success'
        });
        
        // –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–≥—Ä—É–∑–∫–∞–º–∏
        await this.delay(500);
        
      } catch (error) {
        results.push({
          filename: file.name,
          status: 'failed',
          error: error.message
        });
      }
    }
    
    return results;
  }
  
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

---

## üö¶ **9. Routes —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è**

### **–ì–ª–∞–≤–Ω—ã–π mint route:**
```javascript
// routes/mint.js
const express = require('express');
const multer = require('multer');
const { v4: uuidv4 } = require('uuid');
const router = express.Router();

const SolanaService = require('../services/solana');
const PinataService = require('../services/pinata');
const DatabaseService = require('../services/supabase');
const MintQueue = require('../services/queue');
const { validateMintRequest } = require('../services/validation');

const solana = new SolanaService();
const pinata = new PinataService();
const db = new DatabaseService();
const queue = new MintQueue();

// Middleware –¥–ª—è —Ñ–∞–π–ª–æ–≤
const upload = multer({ 
  dest: '/tmp/uploads/',
  limits: { fileSize: 10 * 1024 * 1024 } // 10MB
});

// POST /api/mint/single
router.post('/single', upload.single('image'), async (req, res) => {
  try {
    const { collectionId, recipient, metadata, copies = 1 } = req.body;
    
    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    const validationErrors = validateMintRequest({ collectionId, recipient, metadata });
    if (validationErrors.length > 0) {
      return res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: validationErrors
      });
    }
    
    // –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –∏–∑ –±–∞–∑—ã
    const collection = await db.getCollection(collectionId);
    if (!collection || !collection.allow_minting) {
      return res.status(404).json({
        success: false,
        error: 'Collection not found or minting disabled'
      });
    }
    
    // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∑–∞–¥–∞—á–∏ –¥–ª—è –æ—á–µ—Ä–µ–¥–∏
    const taskData = {
      collectionId,
      collection,
      recipient,
      metadata: JSON.parse(metadata),
      copies: parseInt(copies),
      imageFile: req.file
    };
    
    // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –æ—á–µ—Ä–µ–¥—å
    const transactionId = await queue.addMintTask({
      type: 'single',
      data: taskData,
      priority: 1
    });
    
    // –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –≤ –±–∞–∑–µ
    await db.createMintOperation({
      transactionId,
      collectionId,
      recipient,
      operationType: 'mint',
      totalNfts: copies,
      metadata: taskData.metadata
    });
    
    res.json({
      success: true,
      data: {
        transactionId,
        estimatedTime: copies * 3, // 3 —Å–µ–∫—É–Ω–¥—ã –Ω–∞ NFT
        status: 'queued'
      },
      message: 'Mint operation queued successfully'
    });
    
  } catch (error) {
    console.error('Mint single error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// POST /api/mint/batch
router.post('/batch', upload.array('images', 50), async (req, res) => {
  try {
    const { collectionId, recipient, nfts, batchSize = 10 } = req.body;
    
    // –ü–∞—Ä—Å–∏–Ω–≥ NFT –¥–∞–Ω–Ω—ã—Ö
    const nftData = JSON.parse(nfts);
    const totalNfts = nftData.reduce((sum, nft) => sum + (nft.copies || 1), 0);
    
    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    if (totalNfts > 1000) {
      return res.status(400).json({
        success: false,
        error: 'Too many NFTs in batch (max 1000)'
      });
    }
    
    // –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏
    const collection = await db.getCollection(collectionId);
    if (!collection || !collection.allow_minting) {
      return res.status(404).json({
        success: false,
        error: 'Collection not found or minting disabled'
      });
    }
    
    // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∑–∞–¥–∞—á–∏
    const taskData = {
      collectionId,
      collection,
      recipient,
      nfts: nftData,
      batchSize: parseInt(batchSize),
      imageFiles: req.files
    };
    
    const transactionId = await queue.addMintTask({
      type: 'batch',
      data: taskData,
      priority: 0
    });
    
    await db.createMintOperation({
      transactionId,
      collectionId,
      recipient,
      operationType: 'batch_mint',
      totalNfts,
      batchSize: parseInt(batchSize),
      metadata: { nfts: nftData }
    });
    
    res.json({
      success: true,
      data: {
        transactionId,
        totalNfts,
        estimatedTime: Math.ceil(totalNfts / batchSize) * 30, // 30 —Å–µ–∫ –Ω–∞ batch
        batchCount: Math.ceil(totalNfts / batchSize)
      },
      message: 'Batch mint operation queued successfully'
    });
    
  } catch (error) {
    console.error('Batch mint error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// GET /api/mint/status/:transactionId
router.get('/status/:transactionId', async (req, res) => {
  try {
    const { transactionId } = req.params;
    
    // –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–∑ –±–∞–∑—ã
    const operation = await db.getMintOperation(transactionId);
    if (!operation) {
      return res.status(404).json({
        success: false,
        error: 'Operation not found'
      });
    }
    
    // –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    const results = await db.getMintResults(operation.id);
    
    // –ü–æ–¥—Å—á–µ—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
    const progress = {
      total: operation.total_nfts,
      completed: operation.completed_nfts,
      failed: operation.failed_nfts,
      percentage: Math.round((operation.completed_nfts / operation.total_nfts) * 100)
    };
    
    // –û—Ü–µ–Ω–∫–∞ –≤—Ä–µ–º–µ–Ω–∏
    if (operation.status === 'processing' && progress.completed > 0) {
      const elapsed = Date.now() - new Date(operation.start_time).getTime();
      const avgTimePerNft = elapsed / progress.completed;
      const remaining = operation.total_nfts - progress.completed;
      progress.estimatedTimeLeft = Math.ceil((remaining * avgTimePerNft) / 1000);
    }
    
    res.json({
      success: true,
      data: {
        transactionId: operation.transaction_id,
        status: operation.status,
        progress,
        results: results.map(r => ({
          signature: r.signature,
          leafIndex: r.leaf_index,
          assetId: r.asset_id,
          status: r.status,
          error: r.error_message
        })),
        startTime: operation.start_time,
        endTime: operation.end_time,
        error: operation.error_message
      }
    });
    
  } catch (error) {
    console.error('Status check error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// DELETE /api/mint/cancel/:transactionId
router.delete('/cancel/:transactionId', async (req, res) => {
  try {
    const { transactionId } = req.params;
    
    // –û—Ç–º–µ–Ω–∞ –≤ –æ—á–µ—Ä–µ–¥–∏
    queue.cancelTask(transactionId);
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤ –±–∞–∑–µ
    await db.updateMintOperation(transactionId, {
      status: 'cancelled',
      end_time: new Date().toISOString()
    });
    
    res.json({
      success: true,
      message: 'Operation cancelled successfully'
    });
    
  } catch (error) {
    console.error('Cancel error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

module.exports = router;
```

---

## üìä **10. –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ**

### **Logger —Å–∏—Å—Ç–µ–º–∞:**
```javascript
// utils/logger.js
const winston = require('winston');

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'nft-backend' },
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
    new winston.transports.Console({
      format: winston.format.simple()
    })
  ]
});

// Middleware –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è HTTP –∑–∞–ø—Ä–æ—Å–æ–≤
const httpLogger = (req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    logger.info('HTTP Request', {
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration,
      userAgent: req.get('User-Agent'),
      ip: req.ip
    });
  });
  
  next();
};

module.exports = { logger, httpLogger };
```

### **–ú–µ—Ç—Ä–∏–∫–∏:**
```javascript
// utils/metrics.js
class MetricsCollector {
  constructor() {
    this.metrics = {
      mintsTotal: 0,
      mintsSuccess: 0,
      mintsFailed: 0,
      uploadsTotal: 0,
      uploadsSuccess: 0,
      uploadsFailed: 0,
      avgMintTime: 0,
      activeOperations: 0
    };
  }
  
  incrementMints(success = true) {
    this.metrics.mintsTotal++;
    if (success) {
      this.metrics.mintsSuccess++;
    } else {
      this.metrics.mintsFailed++;
    }
  }
  
  recordMintTime(duration) {
    // Exponential moving average
    this.metrics.avgMintTime = this.metrics.avgMintTime * 0.9 + duration * 0.1;
  }
  
  getMetrics() {
    return {
      ...this.metrics,
      successRate: this.metrics.mintsTotal > 0 
        ? (this.metrics.mintsSuccess / this.metrics.mintsTotal) * 100 
        : 0
    };
  }
}

const metrics = new MetricsCollector();
module.exports = metrics;
```

---

## üîß **11. –ì–ª–∞–≤–Ω—ã–π app.js —Ñ–∞–π–ª**

```javascript
// app.js
const express = require('express');
const cors = require('cors');
require('dotenv').config();

// Middleware
const { httpLogger } = require('./utils/logger');
const authMiddleware = require('./middleware/auth');
const errorHandler = require('./middleware/errorHandler');
const { mintRateLimit, uploadRateLimit } = require('./middleware/rateLimit');

// Routes
const mintRoutes = require('./routes/mint');
const collectionsRoutes = require('./routes/collections');
const uploadRoutes = require('./routes/upload');
const statsRoutes = require('./routes/stats');
const healthRoutes = require('./routes/health');

const app = express();
const PORT = process.env.PORT || 8080;

// Trust proxy (–¥–ª—è TimeWeb)
app.set('trust proxy', 1);

// Global middleware
app.use(httpLogger);
app.use(cors({
  origin: process.env.CORS_ORIGINS?.split(',') || ['https://your-frontend.vercel.app'],
  credentials: true
}));
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// Health check (–±–µ–∑ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏)
app.use('/health', healthRoutes);

// API routes (—Å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–µ–π)
app.use('/api/mint', authMiddleware, mintRateLimit, mintRoutes);
app.use('/api/collections', authMiddleware, collectionsRoutes);
app.use('/api/upload', authMiddleware, uploadRateLimit, uploadRoutes);
app.use('/api/stats', authMiddleware, statsRoutes);

// Error handling
app.use(errorHandler);

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({
    success: false,
    error: 'Endpoint not found'
  });
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM received, shutting down gracefully');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('SIGINT received, shutting down gracefully');
  process.exit(0);
});

app.listen(PORT, '0.0.0.0', () => {
  console.log(`üöÄ NFT Backend server running on port ${PORT}`);
  console.log(`üìä Environment: ${process.env.NODE_ENV}`);
  console.log(`üîó Network: ${process.env.NETWORK}`);
});

module.exports = app;
```

---

## üì¶ **12. package.json –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏**

```json
{
  "name": "pecoin-nft-backend",
  "version": "1.0.0",
  "description": "NFT Minting Backend for PEcamp Dashboard",
  "main": "app.js",
  "scripts": {
    "start": "node app.js",
    "dev": "nodemon app.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "multer": "^1.4.5-lts.1",
    "express-rate-limit": "^7.1.5",
    "winston": "^3.11.0",
    "uuid": "^9.0.1",
    
    "// Solana & Crypto": "",
    "@metaplex-foundation/umi-bundle-defaults": "^0.9.1",
    "@metaplex-foundation/mpl-bubblegum": "^0.7.0",
    "@solana/web3.js": "^1.87.6",
    "bs58": "^5.0.0",
    
    "// IPFS": "",
    "@pinata/sdk": "^2.1.0",
    
    "// Database": "",
    "@supabase/supabase-js": "^2.38.5",
    
    "// Auth & Security": "",
    "jsonwebtoken": "^9.0.2",
    "bcrypt": "^5.1.1",
    "helmet": "^7.1.0",
    
    "// Utils": "",
    "lodash": "^4.17.21",
    "moment": "^2.29.4",
    "sharp": "^0.32.6"
  },
  "devDependencies": {
    "nodemon": "^3.0.2",
    "jest": "^29.7.0",
    "supertest": "^6.3.3",
    "eslint": "^8.55.0"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
```

---

## üîå **13. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Frontend**

### **Frontend –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ Next.js:**

#### **–û–±–Ω–æ–≤–∏—Ç—å API base URL:**
```javascript
// lib/api-client.js
```javascript
// lib/api-client.js
const API_BASE_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'https://your-backend.timeweb.cloud';
const API_KEY = process.env.NEXT_PUBLIC_API_KEY;

class NFTBackendClient {
  constructor() {
    this.baseURL = API_BASE_URL;
    this.defaultHeaders = {
      'Content-Type': 'application/json',
      'X-API-Key': API_KEY
    };
  }
  
  // –ú–∏–Ω—Ç –æ–¥–Ω–æ–≥–æ NFT
  async mintSingle(data) {
    const formData = new FormData();
    formData.append('collectionId', data.collectionId);
    formData.append('recipient', data.recipient);
    formData.append('metadata', JSON.stringify(data.metadata));
    formData.append('copies', data.copies.toString());
    
    if (data.imageFile) {
      formData.append('image', data.imageFile);
    }
    
    const response = await fetch(`${this.baseURL}/api/mint/single`, {
      method: 'POST',
      headers: {
        'X-API-Key': API_KEY
        // –ù–ï —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º Content-Type –¥–ª—è FormData
      },
      body: formData
    });
    
    return this.handleResponse(response);
  }
  
  // Batch –º–∏–Ω—Ç
  async mintBatch(data) {
    const formData = new FormData();
    formData.append('collectionId', data.collectionId);
    formData.append('recipient', data.recipient);
    formData.append('nfts', JSON.stringify(data.nfts));
    formData.append('batchSize', data.batchSize.toString());
    
    // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ñ–∞–π–ª–æ–≤
    data.imageFiles.forEach((file, index) => {
      formData.append('images', file);
    });
    
    const response = await fetch(`${this.baseURL}/api/mint/batch`, {
      method: 'POST',
      headers: {
        'X-API-Key': API_KEY
      },
      body: formData
    });
    
    return this.handleResponse(response);
  }
  
  // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –æ–ø–µ—Ä–∞—Ü–∏–∏
  async getMintStatus(transactionId) {
    const response = await fetch(`${this.baseURL}/api/mint/status/${transactionId}`, {
      headers: this.defaultHeaders
    });
    
    return this.handleResponse(response);
  }
  
  // –û—Ç–º–µ–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏–∏
  async cancelMint(transactionId) {
    const response = await fetch(`${this.baseURL}/api/mint/cancel/${transactionId}`, {
      method: 'DELETE',
      headers: this.defaultHeaders
    });
    
    return this.handleResponse(response);
  }
  
  // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
  async getStats() {
    const response = await fetch(`${this.baseURL}/api/stats/overview`, {
      headers: this.defaultHeaders
    });
    
    return this.handleResponse(response);
  }
  
  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–æ–≤
  async handleResponse(response) {
    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || `HTTP ${response.status}`);
    }
    
    return data;
  }
}

export const nftBackendClient = new NFTBackendClient();
```

#### **–û–±–Ω–æ–≤–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π upload page:**
```typescript
// app/admin/nft-minting/upload/page.tsx
'use client'

import { useState, useRef } from 'react'
import { nftBackendClient } from '@/lib/api-client'
import { toast } from '@/hooks/use-toast'

// –ó–∞–º–µ–Ω–∏—Ç—å —Å–∏–º—É–ª—è—Ü–∏—é –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–µ –≤—ã–∑–æ–≤—ã
const handleRealMinting = async () => {
  if (!selectedCollection || uploadedFiles.length === 0) {
    toast({
      title: "–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏",
      description: "–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–ª–ª–µ–∫—Ü–∏—é –∏ –∑–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–∞–π–ª—ã",
      variant: "destructive"
    })
    return
  }

  setIsMinting(true)
  
  try {
    let transactionId: string;
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –æ–ø–µ—Ä–∞—Ü–∏–∏
    const totalNfts = uploadedFiles.reduce((sum, f) => sum + f.copies, 0)
    
    if (totalNfts === 1) {
      // –û–¥–∏–Ω–æ—á–Ω—ã–π –º–∏–Ω—Ç
      const file = uploadedFiles[0]
      const result = await nftBackendClient.mintSingle({
        collectionId: selectedCollection,
        recipient: file.recipient,
        metadata: {
          name: file.name,
          description: `Generated NFT from ${file.file.name}`,
          attributes: []
        },
        copies: file.copies,
        imageFile: file.file
      })
      
      transactionId = result.data.transactionId
      
    } else {
      // Batch –º–∏–Ω—Ç
      const nfts = uploadedFiles.map(file => ({
        name: file.name,
        description: `Generated NFT from ${file.file.name}`,
        copies: file.copies
      }))
      
      const imageFiles = uploadedFiles.map(file => file.file)
      
      const result = await nftBackendClient.mintBatch({
        collectionId: selectedCollection,
        recipient: uploadedFiles[0].recipient, // –í—Å–µ –≤ –æ–¥–∏–Ω –∫–æ—à–µ–ª–µ–∫
        nfts,
        imageFiles,
        batchSize: 10
      })
      
      transactionId = result.data.transactionId
    }
    
    // –ó–∞–ø—É—Å–∫ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
    startProgressTracking(transactionId)
    
    toast({
      title: "–ú–∏–Ω—Ç–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω! üöÄ",
      description: `–û–ø–µ—Ä–∞—Ü–∏—è ${transactionId} –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –æ—á–µ—Ä–µ–¥—å`,
    })
    
  } catch (error) {
    console.error('Minting failed:', error)
    setIsMinting(false)
    
    toast({
      title: "–û—à–∏–±–∫–∞ –º–∏–Ω—Ç–∏–Ω–≥–∞",
      description: error instanceof Error ? error.message : "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å –º–∏–Ω—Ç–∏–Ω–≥",
      variant: "destructive"
    })
  }
}

// –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
const startProgressTracking = (transactionId: string) => {
  const interval = setInterval(async () => {
    try {
      const statusResult = await nftBackendClient.getMintStatus(transactionId)
      const status = statusResult.data
      
      // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
      setMintingProgress({
        total: status.progress.total,
        completed: status.progress.completed,
        failed: status.progress.failed,
        current: status.progress.currentItem || 'Processing...',
        percentage: status.progress.percentage,
        startTime: Date.now(),
        estimatedTimeLeft: status.progress.estimatedTimeLeft || 0
      })
      
      // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–æ–≤ —Ñ–∞–π–ª–æ–≤
      updateFileStatuses(status.results)
      
      // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
      if (status.status === 'completed' || status.status === 'failed') {
        clearInterval(interval)
        setIsMinting(false)
        
        if (status.status === 'completed') {
          toast({
            title: "–ú–∏–Ω—Ç–∏–Ω–≥ –∑–∞–≤–µ—Ä—à–µ–Ω! ‚úÖ",
            description: `–£—Å–ø–µ—à–Ω–æ –∑–∞–º–∏–Ω—á–µ–Ω–æ ${status.progress.completed} NFT`,
          })
        } else {
          toast({
            title: "–ú–∏–Ω—Ç–∏–Ω–≥ –∑–∞–≤–µ—Ä—à–µ–Ω —Å –æ—à–∏–±–∫–∞–º–∏",
            description: status.error || "–ù–µ–∫–æ—Ç–æ—Ä—ã–µ NFT –Ω–µ –±—ã–ª–∏ —Å–æ–∑–¥–∞–Ω—ã",
            variant: "destructive"
          })
        }
      }
      
    } catch (error) {
      console.error('Status check failed:', error)
      clearInterval(interval)
      setIsMinting(false)
    }
  }, 2000) // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 2 —Å–µ–∫—É–Ω–¥—ã
}
```

#### **–û–±–Ω–æ–≤–∏—Ç—å environment –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ Frontend:**
```bash
# .env.local –¥–ª—è Next.js
NEXT_PUBLIC_BACKEND_URL=https://your-backend.timeweb.cloud
NEXT_PUBLIC_API_KEY=your_api_key_from_backend

# –û—Å—Ç–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ—Å—Ç–∞—é—Ç—Å—è –∫–∞–∫ –µ—Å—Ç—å
NEXT_PUBLIC_SUPABASE_URL=...
NEXT_PUBLIC_SUPABASE_ANON_KEY=...
```

---

## üß™ **14. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ**

### **–Æ–Ω–∏—Ç —Ç–µ—Å—Ç—ã:**
```javascript
// tests/services/solana.test.js
const SolanaService = require('../../src/services/solana');

describe('SolanaService', () => {
  let solanaService;
  
  beforeEach(() => {
    solanaService = new SolanaService();
  });
  
  test('should initialize connection to Solana RPC', async () => {
    await expect(solanaService.initialize()).resolves.not.toThrow();
    expect(solanaService.initialized).toBe(true);
  });
  
  test('should get wallet balance', async () => {
    await solanaService.initialize();
    const balance = await solanaService.getWalletBalance();
    expect(typeof balance).toBe('number');
    expect(balance).toBeGreaterThanOrEqual(0);
  });
});

// tests/routes/mint.test.js
const request = require('supertest');
const app = require('../../src/app');

describe('Mint API', () => {
  const validApiKey = process.env.API_KEY;
  
  test('POST /api/mint/single should require authentication', async () => {
    const response = await request(app)
      .post('/api/mint/single')
      .send({
        collectionId: 'test-collection',
        recipient: 'test-wallet',
        metadata: { name: 'Test NFT' }
      });
      
    expect(response.status).toBe(401);
  });
  
  test('POST /api/mint/single should validate required fields', async () => {
    const response = await request(app)
      .post('/api/mint/single')
      .set('X-API-Key', validApiKey)
      .send({
        // –ù–∞–º–µ—Ä–µ–Ω–Ω–æ –ø—Ä–æ–ø—É—â–µ–Ω—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è
      });
      
    expect(response.status).toBe(400);
    expect(response.body.success).toBe(false);
  });
});
```

### **–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã:**
```javascript
// tests/integration/mint-flow.test.js
describe('Complete Mint Flow', () => {
  test('should mint NFT end-to-end on devnet', async () => {
    // 1. –°–æ–∑–¥–∞—Ç—å —Ç–µ—Å—Ç–æ–≤—É—é –∫–æ–ª–ª–µ–∫—Ü–∏—é
    const collection = await createTestCollection();
    
    // 2. –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ç–µ—Å—Ç–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    const imageUpload = await uploadTestImage();
    
    // 3. –ó–∞–ø—É—Å—Ç–∏—Ç—å –º–∏–Ω—Ç
    const mintResult = await startMint({
      collectionId: collection.id,
      recipient: TEST_WALLET,
      metadata: {
        name: 'Integration Test NFT',
        image: imageUpload.ipfsUri
      }
    });
    
    // 4. –î–æ–∂–¥–∞—Ç—å—Å—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
    const finalStatus = await waitForCompletion(mintResult.transactionId);
    
    // 5. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    expect(finalStatus.status).toBe('completed');
    expect(finalStatus.results[0].signature).toBeDefined();
    
    // 6. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å NFT –≤ –±–ª–æ–∫—á–µ–π–Ω–µ
    const nftExists = await checkNftInBlockchain(finalStatus.results[0].assetId);
    expect(nftExists).toBe(true);
  }, 30000); // 30 —Å–µ–∫—É–Ω–¥ timeout
});
```

---

## üöÄ **15. Deployment –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏**

### **Checklist –ø–µ—Ä–µ–¥ –¥–µ–ø–ª–æ–µ–º:**
- [ ] ‚úÖ GitHub —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π —Å–æ–∑–¥–∞–Ω –∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω
- [ ] ‚úÖ TimeWeb –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–æ
- [ ] ‚úÖ Environment –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã
- [ ] ‚úÖ Solana –∫–æ—à–µ–ª–µ–∫ —Å–æ–∑–¥–∞–Ω –∏ –ø–æ–ø–æ–ª–Ω–µ–Ω
- [ ] ‚úÖ Alchemy RPC endpoint –ø–æ–ª—É—á–µ–Ω
- [ ] ‚úÖ Pinata API –∫–ª—é—á–∏ –ø–æ–ª—É—á–µ–Ω—ã
- [ ] ‚úÖ Supabase —Ç–∞–±–ª–∏—Ü—ã —Å–æ–∑–¥–∞–Ω—ã
- [ ] ‚úÖ Frontend –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω—ã

### **–ü–µ—Ä–≤–∏—á–Ω–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞:**
```bash
# 1. –ü–æ–ø–æ–ª–Ω–∏—Ç—å Solana –∫–æ—à–µ–ª–µ–∫ (devnet –¥–ª—è —Ç–µ—Å—Ç–æ–≤)
solana airdrop 2 YOUR_WALLET_ADDRESS --url devnet

# 2. –°–æ–∑–¥–∞—Ç—å —Ç–µ—Å—Ç–æ–≤—É—é –∫–æ–ª–ª–µ–∫—Ü–∏—é –∏ –¥–µ—Ä–µ–≤–æ (—á–µ—Ä–µ–∑ reference-code)
# –ó–∞–ø—É—Å—Ç–∏—Ç—å –ª–æ–∫–∞–ª—å–Ω–æ create_merkle_tree.js –∏ create_collection.js

# 3. –ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–æ–ª–ª–µ–∫—Ü–∏—é –≤ –±–∞–∑—É —á–µ—Ä–µ–∑ frontend
# /admin/nft-minting/settings -> Import Collection

# 4. –ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –æ–¥–∏–Ω NFT —á–µ—Ä–µ–∑ API
curl -X POST https://your-backend.timeweb.cloud/api/mint/single \
  -H "X-API-Key: your_api_key" \
  -H "Content-Type: application/json" \
  -d '{
    "collectionId": "your-collection-id",
    "recipient": "test-wallet-address", 
    "metadata": {
      "name": "Test NFT",
      "description": "First test mint"
    },
    "copies": 1
  }'
```

### **–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø–æ—Å–ª–µ –¥–µ–ø–ª–æ—è:**
```bash
# –õ–æ–≥–∏ TimeWeb
tail -f /logs/combined.log

# –ü—Ä–æ–≤–µ—Ä–∫–∞ health
curl https://your-backend.timeweb.cloud/health

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–µ—Ç—Ä–∏–∫
curl -H "X-API-Key: your_api_key" \
  https://your-backend.timeweb.cloud/api/stats/overview
```

---

## üîß **16. Troubleshooting –≥–∏–¥**

### **–ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏ –∏ —Ä–µ—à–µ–Ω–∏—è:**

#### **üö® "Failed to connect to Solana RPC"**
```bash
# –ü—Ä–æ–≤–µ—Ä–∏—Ç—å RPC endpoints
curl -X POST https://api.mainnet-beta.solana.com \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","id":1,"method":"getHealth"}'

# –ü—Ä–æ–≤–µ—Ä–∏—Ç—å Alchemy –∫–ª—é—á
curl https://solana-mainnet.g.alchemy.com/v2/YOUR_KEY \
  -X POST \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","id":1,"method":"getVersion"}'
```

#### **üö® "Insufficient SOL balance"**
```bash
# –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å –∫–æ—à–µ–ª—å–∫–∞
solana balance YOUR_WALLET_ADDRESS

# –ü–æ–ø–æ–ª–Ω–∏—Ç—å –∫–æ—à–µ–ª–µ–∫ (mainnet —Ç—Ä–µ–±—É–µ—Ç —Ä–µ–∞–ª—å–Ω—ã–µ SOL)
# –î–ª—è devnet: solana airdrop 2 YOUR_WALLET_ADDRESS --url devnet
```

#### **üö® "Tree capacity exceeded"**
```javascript
// –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–µ –¥–µ—Ä–µ–≤–æ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ —Å –º–µ—Å—Ç–æ–º
// –ü—Ä–æ–≤–µ—Ä–∏—Ç—å capacity –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö nft_collections —Ç–∞–±–ª–∏—Ü–µ
```

#### **üö® "IPFS upload failed"**
```bash
# –ü—Ä–æ–≤–µ—Ä–∏—Ç—å Pinata –∫–ª—é—á–∏
curl -X GET https://api.pinata.cloud/data/testAuthentication \
  -H "pinata_api_key: YOUR_API_KEY" \
  -H "pinata_secret_api_key: YOUR_SECRET_KEY"
```

#### **üö® "Database connection failed"**
```bash
# –ü—Ä–æ–≤–µ—Ä–∏—Ç—å Supabase –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
curl "YOUR_SUPABASE_URL/rest/v1/nft_collections?select=*" \
  -H "apikey: YOUR_SERVICE_ROLE_KEY"
```

---

## üìã **17. –§–∏–Ω–∞–ª—å–Ω—ã–π —á–µ–∫–ª–∏—Å—Ç –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏**

### **Backend –≥–æ—Ç–æ–≤ –∫ –ø—Ä–æ–¥–∞–∫—à–µ–Ω—É –∫–æ–≥–¥–∞:**
- [ ] ‚úÖ –í—Å–µ API endpoints –æ—Ç–≤–µ—á–∞—é—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
- [ ] ‚úÖ –ú–∏–Ω—Ç –æ–¥–Ω–æ–≥–æ NFT —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ devnet
- [ ] ‚úÖ Batch –º–∏–Ω—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ devnet  
- [ ] ‚úÖ Progress tracking —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∏—Ä—É–µ—Ç
- [ ] ‚úÖ Error handling –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—Å–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏
- [ ] ‚úÖ Rate limiting –∑–∞—â–∏—â–∞–µ—Ç –æ—Ç —Å–ø–∞–º–∞
- [ ] ‚úÖ –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç –≤—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
- [ ] ‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
- [ ] ‚úÖ Frontend —É—Å–ø–µ—à–Ω–æ –∏–Ω—Ç–µ–≥—Ä–∏—Ä—É–µ—Ç—Å—è
- [ ] ‚úÖ –¢–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç —É—Å–ø–µ—à–Ω–æ

### **–ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ mainnet:**
1. **–û–±–Ω–æ–≤–∏—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ:**
   ```bash
   NETWORK=mainnet-beta
   RPC_URL=alchemy_mainnet_url
   ```
2. **–ü–æ–ø–æ–ª–Ω–∏—Ç—å –∫–æ—à–µ–ª–µ–∫ —Ä–µ–∞–ª—å–Ω—ã–º–∏ SOL**
3. **–°–æ–∑–¥–∞—Ç—å production –∫–æ–ª–ª–µ–∫—Ü–∏–∏**
4. **–û–±–Ω–æ–≤–∏—Ç—å frontend URLs**
5. **–ü—Ä–æ–≤–µ—Å—Ç–∏ —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ**

---

## üéØ **18. –ó–∞–∫–ª—é—á–µ–Ω–∏–µ**

–î–∞–Ω–Ω–æ–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–µ –∑–∞–¥–∞–Ω–∏–µ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç:

‚úÖ **–ü–æ–ª–Ω—É—é –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—é** —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º frontend  
‚úÖ **–ë–µ–∑–æ–ø–∞—Å–Ω—É—é —Ä–∞–±–æ—Ç—É** —Å –ø—Ä–∏–≤–∞—Ç–Ω—ã–º–∏ –∫–ª—é—á–∞–º–∏  
‚úÖ **–ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º—É—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É** –¥–ª—è —Ä–æ—Å—Ç–∞ –Ω–∞–≥—Ä—É–∑–∫–∏  
‚úÖ **–ù–∞–¥–µ–∂–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫** –∏ retry –ª–æ–≥–∏–∫—É  
‚úÖ **Real-time –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ** –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –æ–ø–µ—Ä–∞—Ü–∏–π  
‚úÖ **Compliance** —Å Solana –∏ NFT —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞–º–∏  
‚úÖ **–ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ –ø—Ä–æ–¥–∞–∫—à–µ–Ω—É** —Å –ø–µ—Ä–≤–æ–≥–æ –¥–Ω—è  

### **–û–∂–∏–¥–∞–µ–º—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã:**
- **Single NFT mint:** 3-5 —Å–µ–∫—É–Ω–¥
- **Batch 30 NFTs:** 2-5 –º–∏–Ω—É—Ç  
- **Success rate:** 95%+ –ø—Ä–∏ —Å—Ç–∞–±–∏–ª—å–Ω–æ–π —Å–µ—Ç–∏
- **Cost per cNFT:** ~0.00025 SOL (~$0.05)
- **Uptime:** 99%+ –Ω–∞ TimeWeb infrastructure

### **–î–∞–ª—å–Ω–µ–π—à–µ–µ —Ä–∞–∑–≤–∏—Ç–∏–µ:**
- WebSocket –¥–ª—è real-time –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π
- Advanced retry –ª–æ–≥–∏–∫–∞ —Å exponential backoff
- NFT metadata validation –∏ enhancement
- Analytics dashboard –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π
- Multi-signature –ø–æ–¥–¥–µ—Ä–∂–∫–∞ –¥–ª—è enterprise

**–≠—Ç–æ—Ç backend –ø–æ–ª–Ω–æ—Å—Ç—å—é –≥–æ—Ç–æ–≤ –¥–ª—è –≤–Ω–µ–¥—Ä–µ–Ω–∏—è —Ä–µ–∞–ª—å–Ω–æ–≥–æ NFT –º–∏–Ω—Ç–∏–Ω–≥–∞ –≤ —ç–∫–æ—Å–∏—Å—Ç–µ–º—É PEcamp! üöÄ**